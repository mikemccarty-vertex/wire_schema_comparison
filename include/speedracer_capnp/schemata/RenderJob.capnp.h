// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: RenderJob.capnp

#ifndef CAPNP_INCLUDED_8a69b983970c1f1e_
#define CAPNP_INCLUDED_8a69b983970c1f1e_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372184);
enum class DataBufferFormat_bc3ffa1c6e372184: uint16_t {
  E_B_U_F_F_E_R_N_O_N_E,
  E_B_U_F_F_E_R_R_G_B8,
  E_B_U_F_F_E_R_R_G_B_A8,
  E_B_U_F_F_E_R_U_I_N_T16_L_E,
  E_B_U_F_F_E_R_U_I_N_T16_B_E,
  E_B_U_F_F_E_R_F_L_O_A_T32_L_E,
};
CAPNP_DECLARE_ENUM(DataBufferFormat, bc3ffa1c6e372184);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372185);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372186);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372187);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372188);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372189);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372190);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372191);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372192);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372193);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372194);
CAPNP_DECLARE_SCHEMA(bc3ffa1c6e372195);

}  // namespace schemas
}  // namespace capnp

namespace speedracer_capnp {

typedef ::capnp::schemas::DataBufferFormat_bc3ffa1c6e372184 DataBufferFormat;

struct Vector3f {
  Vector3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372185, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Color3f {
  Color3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372186, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Matrix4f {
  Matrix4f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372187, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Viewport {
  Viewport() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372188, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BoundingBox2i {
  BoundingBox2i() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372189, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BoundingBox3f {
  BoundingBox3f() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372190, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DataBuffer {
  DataBuffer() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372191, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FrameID {
  FrameID() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372192, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ImageFragmentBuffers {
  ImageFragmentBuffers() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372193, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ImageFragmentInfo {
  ImageFragmentInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372194, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ImageFragmentList {
  ImageFragmentList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc3ffa1c6e372195, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Vector3f::Reader {
public:
  typedef Vector3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3f::Builder {
public:
  typedef Vector3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3f::Pipeline {
public:
  typedef Vector3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Color3f::Reader {
public:
  typedef Color3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline float getR() const;

  inline float getG() const;

  inline float getB() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Color3f::Builder {
public:
  typedef Color3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline float getR();
  inline void setR(float value);

  inline float getG();
  inline void setG(float value);

  inline float getB();
  inline void setB(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Color3f::Pipeline {
public:
  typedef Color3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Matrix4f::Reader {
public:
  typedef Matrix4f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline bool hasBasisX() const;
  inline  ::speedracer_capnp::Vector3f::Reader getBasisX() const;

  inline bool hasBasisY() const;
  inline  ::speedracer_capnp::Vector3f::Reader getBasisY() const;

  inline bool hasT() const;
  inline  ::speedracer_capnp::Vector3f::Reader getT() const;

  inline float getS() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Matrix4f::Builder {
public:
  typedef Matrix4f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline bool hasBasisX();
  inline  ::speedracer_capnp::Vector3f::Builder getBasisX();
  inline void setBasisX( ::speedracer_capnp::Vector3f::Reader value);
  inline  ::speedracer_capnp::Vector3f::Builder initBasisX();
  inline void adoptBasisX(::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> disownBasisX();

  inline bool hasBasisY();
  inline  ::speedracer_capnp::Vector3f::Builder getBasisY();
  inline void setBasisY( ::speedracer_capnp::Vector3f::Reader value);
  inline  ::speedracer_capnp::Vector3f::Builder initBasisY();
  inline void adoptBasisY(::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> disownBasisY();

  inline bool hasT();
  inline  ::speedracer_capnp::Vector3f::Builder getT();
  inline void setT( ::speedracer_capnp::Vector3f::Reader value);
  inline  ::speedracer_capnp::Vector3f::Builder initT();
  inline void adoptT(::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> disownT();

  inline float getS();
  inline void setS(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Matrix4f::Pipeline {
public:
  typedef Matrix4f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::speedracer_capnp::Vector3f::Pipeline getBasisX();
  inline  ::speedracer_capnp::Vector3f::Pipeline getBasisY();
  inline  ::speedracer_capnp::Vector3f::Pipeline getT();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Viewport::Reader {
public:
  typedef Viewport Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline  ::int32_t getWidth() const;

  inline  ::int32_t getHeight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Viewport::Builder {
public:
  typedef Viewport Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline  ::int32_t getWidth();
  inline void setWidth( ::int32_t value);

  inline  ::int32_t getHeight();
  inline void setHeight( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Viewport::Pipeline {
public:
  typedef Viewport Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BoundingBox2i::Reader {
public:
  typedef BoundingBox2i Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline  ::int32_t getXmin() const;

  inline  ::int32_t getXmax() const;

  inline  ::int32_t getYmin() const;

  inline  ::int32_t getYmax() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BoundingBox2i::Builder {
public:
  typedef BoundingBox2i Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline  ::int32_t getXmin();
  inline void setXmin( ::int32_t value);

  inline  ::int32_t getXmax();
  inline void setXmax( ::int32_t value);

  inline  ::int32_t getYmin();
  inline void setYmin( ::int32_t value);

  inline  ::int32_t getYmax();
  inline void setYmax( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BoundingBox2i::Pipeline {
public:
  typedef BoundingBox2i Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BoundingBox3f::Reader {
public:
  typedef BoundingBox3f Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline float getXmin() const;

  inline float getXmax() const;

  inline float getYmin() const;

  inline float getYmax() const;

  inline float getZmin() const;

  inline float getZmax() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BoundingBox3f::Builder {
public:
  typedef BoundingBox3f Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline float getXmin();
  inline void setXmin(float value);

  inline float getXmax();
  inline void setXmax(float value);

  inline float getYmin();
  inline void setYmin(float value);

  inline float getYmax();
  inline void setYmax(float value);

  inline float getZmin();
  inline void setZmin(float value);

  inline float getZmax();
  inline void setZmax(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BoundingBox3f::Pipeline {
public:
  typedef BoundingBox3f Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DataBuffer::Reader {
public:
  typedef DataBuffer Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline  ::speedracer_capnp::DataBufferFormat getFormat() const;

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DataBuffer::Builder {
public:
  typedef DataBuffer Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline  ::speedracer_capnp::DataBufferFormat getFormat();
  inline void setFormat( ::speedracer_capnp::DataBufferFormat value);

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DataBuffer::Pipeline {
public:
  typedef DataBuffer Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FrameID::Reader {
public:
  typedef FrameID Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline bool hasId() const;
  inline  ::capnp::Text::Reader getId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FrameID::Builder {
public:
  typedef FrameID Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline bool hasId();
  inline  ::capnp::Text::Builder getId();
  inline void setId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initId(unsigned int size);
  inline void adoptId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FrameID::Pipeline {
public:
  typedef FrameID Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ImageFragmentBuffers::Reader {
public:
  typedef ImageFragmentBuffers Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline bool hasExtents() const;
  inline  ::speedracer_capnp::Viewport::Reader getExtents() const;

  inline bool hasPixels() const;
  inline  ::speedracer_capnp::DataBuffer::Reader getPixels() const;

  inline bool hasDepth() const;
  inline  ::speedracer_capnp::DataBuffer::Reader getDepth() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ImageFragmentBuffers::Builder {
public:
  typedef ImageFragmentBuffers Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline bool hasExtents();
  inline  ::speedracer_capnp::Viewport::Builder getExtents();
  inline void setExtents( ::speedracer_capnp::Viewport::Reader value);
  inline  ::speedracer_capnp::Viewport::Builder initExtents();
  inline void adoptExtents(::capnp::Orphan< ::speedracer_capnp::Viewport>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::Viewport> disownExtents();

  inline bool hasPixels();
  inline  ::speedracer_capnp::DataBuffer::Builder getPixels();
  inline void setPixels( ::speedracer_capnp::DataBuffer::Reader value);
  inline  ::speedracer_capnp::DataBuffer::Builder initPixels();
  inline void adoptPixels(::capnp::Orphan< ::speedracer_capnp::DataBuffer>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::DataBuffer> disownPixels();

  inline bool hasDepth();
  inline  ::speedracer_capnp::DataBuffer::Builder getDepth();
  inline void setDepth( ::speedracer_capnp::DataBuffer::Reader value);
  inline  ::speedracer_capnp::DataBuffer::Builder initDepth();
  inline void adoptDepth(::capnp::Orphan< ::speedracer_capnp::DataBuffer>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::DataBuffer> disownDepth();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ImageFragmentBuffers::Pipeline {
public:
  typedef ImageFragmentBuffers Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::speedracer_capnp::Viewport::Pipeline getExtents();
  inline  ::speedracer_capnp::DataBuffer::Pipeline getPixels();
  inline  ::speedracer_capnp::DataBuffer::Pipeline getDepth();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ImageFragmentInfo::Reader {
public:
  typedef ImageFragmentInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasBounds() const;
  inline  ::speedracer_capnp::BoundingBox2i::Reader getBounds() const;

  inline bool getIsOpaque() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ImageFragmentInfo::Builder {
public:
  typedef ImageFragmentInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasBounds();
  inline  ::speedracer_capnp::BoundingBox2i::Builder getBounds();
  inline void setBounds( ::speedracer_capnp::BoundingBox2i::Reader value);
  inline  ::speedracer_capnp::BoundingBox2i::Builder initBounds();
  inline void adoptBounds(::capnp::Orphan< ::speedracer_capnp::BoundingBox2i>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::BoundingBox2i> disownBounds();

  inline bool getIsOpaque();
  inline void setIsOpaque(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ImageFragmentInfo::Pipeline {
public:
  typedef ImageFragmentInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::speedracer_capnp::BoundingBox2i::Pipeline getBounds();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ImageFragmentList::Reader {
public:
  typedef ImageFragmentList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV() const;

  inline bool hasFrame() const;
  inline  ::speedracer_capnp::FrameID::Reader getFrame() const;

  inline bool hasFragments() const;
  inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Reader getFragments() const;

  inline  ::int32_t getTotalCount() const;

  inline  ::int32_t getAccumCount() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ImageFragmentList::Builder {
public:
  typedef ImageFragmentList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::capnp::Void getV();
  inline void setV( ::capnp::Void value = ::capnp::VOID);

  inline bool hasFrame();
  inline  ::speedracer_capnp::FrameID::Builder getFrame();
  inline void setFrame( ::speedracer_capnp::FrameID::Reader value);
  inline  ::speedracer_capnp::FrameID::Builder initFrame();
  inline void adoptFrame(::capnp::Orphan< ::speedracer_capnp::FrameID>&& value);
  inline ::capnp::Orphan< ::speedracer_capnp::FrameID> disownFrame();

  inline bool hasFragments();
  inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Builder getFragments();
  inline void setFragments( ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Reader value);
  inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Builder initFragments(unsigned int size);
  inline void adoptFragments(::capnp::Orphan< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>> disownFragments();

  inline  ::int32_t getTotalCount();
  inline void setTotalCount( ::int32_t value);

  inline  ::int32_t getAccumCount();
  inline void setAccumCount( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ImageFragmentList::Pipeline {
public:
  typedef ImageFragmentList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::speedracer_capnp::FrameID::Pipeline getFrame();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::capnp::Void Vector3f::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Vector3f::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Vector3f::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Vector3f::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3f::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void Color3f::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Color3f::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Color3f::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Color3f::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Color3f::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Color3f::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Color3f::Reader::getG() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Color3f::Builder::getG() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Color3f::Builder::setG(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Color3f::Reader::getB() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Color3f::Builder::getB() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Color3f::Builder::setB(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void Matrix4f::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Matrix4f::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Matrix4f::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Matrix4f::Reader::hasBasisX() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix4f::Builder::hasBasisX() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::Vector3f::Reader Matrix4f::Reader::getBasisX() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::getBasisX() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::Vector3f::Pipeline Matrix4f::Pipeline::getBasisX() {
  return  ::speedracer_capnp::Vector3f::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Matrix4f::Builder::setBasisX( ::speedracer_capnp::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::initBasisX() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Matrix4f::Builder::adoptBasisX(
    ::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> Matrix4f::Builder::disownBasisX() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Matrix4f::Reader::hasBasisY() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix4f::Builder::hasBasisY() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::Vector3f::Reader Matrix4f::Reader::getBasisY() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::getBasisY() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::Vector3f::Pipeline Matrix4f::Pipeline::getBasisY() {
  return  ::speedracer_capnp::Vector3f::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Matrix4f::Builder::setBasisY( ::speedracer_capnp::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::initBasisY() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Matrix4f::Builder::adoptBasisY(
    ::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> Matrix4f::Builder::disownBasisY() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Matrix4f::Reader::hasT() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Matrix4f::Builder::hasT() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::Vector3f::Reader Matrix4f::Reader::getT() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::getT() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::Vector3f::Pipeline Matrix4f::Pipeline::getT() {
  return  ::speedracer_capnp::Vector3f::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Matrix4f::Builder::setT( ::speedracer_capnp::Vector3f::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::Vector3f::Builder Matrix4f::Builder::initT() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Matrix4f::Builder::adoptT(
    ::capnp::Orphan< ::speedracer_capnp::Vector3f>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::Vector3f> Matrix4f::Builder::disownT() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Vector3f>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float Matrix4f::Reader::getS() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Matrix4f::Builder::getS() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Matrix4f::Builder::setS(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void Viewport::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Viewport::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Viewport::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Viewport::Reader::getWidth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Viewport::Builder::getWidth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Viewport::Builder::setWidth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Viewport::Reader::getHeight() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Viewport::Builder::getHeight() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Viewport::Builder::setHeight( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void BoundingBox2i::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void BoundingBox2i::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoundingBox2i::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BoundingBox2i::Reader::getXmin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BoundingBox2i::Builder::getXmin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoundingBox2i::Builder::setXmin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BoundingBox2i::Reader::getXmax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BoundingBox2i::Builder::getXmax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BoundingBox2i::Builder::setXmax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BoundingBox2i::Reader::getYmin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BoundingBox2i::Builder::getYmin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundingBox2i::Builder::setYmin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BoundingBox2i::Reader::getYmax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BoundingBox2i::Builder::getYmax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void BoundingBox2i::Builder::setYmax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void BoundingBox3f::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void BoundingBox3f::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getXmin() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getXmin() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setXmin(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getXmax() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getXmax() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setXmax(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getYmin() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getYmin() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setYmin(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getYmax() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getYmax() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setYmax(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getZmin() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getZmin() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setZmin(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float BoundingBox3f::Reader::getZmax() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline float BoundingBox3f::Builder::getZmax() {
  return _builder.getDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void BoundingBox3f::Builder::setZmax(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void DataBuffer::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void DataBuffer::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DataBuffer::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::speedracer_capnp::DataBufferFormat DataBuffer::Reader::getFormat() const {
  return _reader.getDataField< ::speedracer_capnp::DataBufferFormat>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::speedracer_capnp::DataBufferFormat DataBuffer::Builder::getFormat() {
  return _builder.getDataField< ::speedracer_capnp::DataBufferFormat>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DataBuffer::Builder::setFormat( ::speedracer_capnp::DataBufferFormat value) {
  _builder.setDataField< ::speedracer_capnp::DataBufferFormat>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool DataBuffer::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DataBuffer::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader DataBuffer::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder DataBuffer::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DataBuffer::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder DataBuffer::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void DataBuffer::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> DataBuffer::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::Void FrameID::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FrameID::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FrameID::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FrameID::Reader::hasId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FrameID::Builder::hasId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FrameID::Reader::getId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FrameID::Builder::getId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FrameID::Builder::setId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FrameID::Builder::initId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FrameID::Builder::adoptId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FrameID::Builder::disownId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::capnp::Void ImageFragmentBuffers::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void ImageFragmentBuffers::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentBuffers::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ImageFragmentBuffers::Reader::hasExtents() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentBuffers::Builder::hasExtents() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::Viewport::Reader ImageFragmentBuffers::Reader::getExtents() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::Viewport::Builder ImageFragmentBuffers::Builder::getExtents() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::Viewport::Pipeline ImageFragmentBuffers::Pipeline::getExtents() {
  return  ::speedracer_capnp::Viewport::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ImageFragmentBuffers::Builder::setExtents( ::speedracer_capnp::Viewport::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::Viewport::Builder ImageFragmentBuffers::Builder::initExtents() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ImageFragmentBuffers::Builder::adoptExtents(
    ::capnp::Orphan< ::speedracer_capnp::Viewport>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::Viewport> ImageFragmentBuffers::Builder::disownExtents() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::Viewport>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ImageFragmentBuffers::Reader::hasPixels() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentBuffers::Builder::hasPixels() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::DataBuffer::Reader ImageFragmentBuffers::Reader::getPixels() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::DataBuffer::Builder ImageFragmentBuffers::Builder::getPixels() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::DataBuffer::Pipeline ImageFragmentBuffers::Pipeline::getPixels() {
  return  ::speedracer_capnp::DataBuffer::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ImageFragmentBuffers::Builder::setPixels( ::speedracer_capnp::DataBuffer::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::DataBuffer::Builder ImageFragmentBuffers::Builder::initPixels() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ImageFragmentBuffers::Builder::adoptPixels(
    ::capnp::Orphan< ::speedracer_capnp::DataBuffer>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::DataBuffer> ImageFragmentBuffers::Builder::disownPixels() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ImageFragmentBuffers::Reader::hasDepth() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentBuffers::Builder::hasDepth() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::DataBuffer::Reader ImageFragmentBuffers::Reader::getDepth() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::DataBuffer::Builder ImageFragmentBuffers::Builder::getDepth() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::DataBuffer::Pipeline ImageFragmentBuffers::Pipeline::getDepth() {
  return  ::speedracer_capnp::DataBuffer::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void ImageFragmentBuffers::Builder::setDepth( ::speedracer_capnp::DataBuffer::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::DataBuffer::Builder ImageFragmentBuffers::Builder::initDepth() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ImageFragmentBuffers::Builder::adoptDepth(
    ::capnp::Orphan< ::speedracer_capnp::DataBuffer>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::DataBuffer> ImageFragmentBuffers::Builder::disownDepth() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::DataBuffer>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::capnp::Void ImageFragmentInfo::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void ImageFragmentInfo::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentInfo::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ImageFragmentInfo::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentInfo::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader ImageFragmentInfo::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder ImageFragmentInfo::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ImageFragmentInfo::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder ImageFragmentInfo::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ImageFragmentInfo::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> ImageFragmentInfo::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ImageFragmentInfo::Reader::hasBounds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentInfo::Builder::hasBounds() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::BoundingBox2i::Reader ImageFragmentInfo::Reader::getBounds() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::BoundingBox2i::Builder ImageFragmentInfo::Builder::getBounds() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::BoundingBox2i::Pipeline ImageFragmentInfo::Pipeline::getBounds() {
  return  ::speedracer_capnp::BoundingBox2i::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ImageFragmentInfo::Builder::setBounds( ::speedracer_capnp::BoundingBox2i::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::BoundingBox2i::Builder ImageFragmentInfo::Builder::initBounds() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ImageFragmentInfo::Builder::adoptBounds(
    ::capnp::Orphan< ::speedracer_capnp::BoundingBox2i>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::BoundingBox2i> ImageFragmentInfo::Builder::disownBounds() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::BoundingBox2i>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ImageFragmentInfo::Reader::getIsOpaque() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool ImageFragmentInfo::Builder::getIsOpaque() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentInfo::Builder::setIsOpaque(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::Void ImageFragmentList::Reader::getV() const {
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void ImageFragmentList::Builder::getV() {
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentList::Builder::setV( ::capnp::Void value) {
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ImageFragmentList::Reader::hasFrame() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentList::Builder::hasFrame() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::speedracer_capnp::FrameID::Reader ImageFragmentList::Reader::getFrame() const {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::speedracer_capnp::FrameID::Builder ImageFragmentList::Builder::getFrame() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::speedracer_capnp::FrameID::Pipeline ImageFragmentList::Pipeline::getFrame() {
  return  ::speedracer_capnp::FrameID::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ImageFragmentList::Builder::setFrame( ::speedracer_capnp::FrameID::Reader value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::speedracer_capnp::FrameID::Builder ImageFragmentList::Builder::initFrame() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ImageFragmentList::Builder::adoptFrame(
    ::capnp::Orphan< ::speedracer_capnp::FrameID>&& value) {
  ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::speedracer_capnp::FrameID> ImageFragmentList::Builder::disownFrame() {
  return ::capnp::_::PointerHelpers< ::speedracer_capnp::FrameID>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ImageFragmentList::Reader::hasFragments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ImageFragmentList::Builder::hasFragments() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Reader ImageFragmentList::Reader::getFragments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Builder ImageFragmentList::Builder::getFragments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ImageFragmentList::Builder::setFragments( ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>::Builder ImageFragmentList::Builder::initFragments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ImageFragmentList::Builder::adoptFragments(
    ::capnp::Orphan< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>> ImageFragmentList::Builder::disownFragments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::speedracer_capnp::ImageFragmentInfo>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t ImageFragmentList::Reader::getTotalCount() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ImageFragmentList::Builder::getTotalCount() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentList::Builder::setTotalCount( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t ImageFragmentList::Reader::getAccumCount() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t ImageFragmentList::Builder::getAccumCount() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ImageFragmentList::Builder::setAccumCount( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

}  // namespace

#endif  // CAPNP_INCLUDED_8a69b983970c1f1e_

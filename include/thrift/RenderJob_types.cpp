/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RenderJob_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace speedracer_thrift {

int _kDataBufferFormatValues[] = {
  BUFFER_NONE,
  BUFFER_RGB_8,
  BUFFER_RGBA_8,
  BUFFER_UINT_16_LE,
  BUFFER_UINT_16_BE,
  BUFFER_FLOAT_32_LE
};
const char* _kDataBufferFormatNames[] = {
  "BUFFER_NONE",
  "BUFFER_RGB_8",
  "BUFFER_RGBA_8",
  "BUFFER_UINT_16_LE",
  "BUFFER_UINT_16_BE",
  "BUFFER_FLOAT_32_LE"
};
const std::map<int, const char*> _DataBufferFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kDataBufferFormatValues, _kDataBufferFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Vector3f::~Vector3f() throw() {
}


void Vector3f::__set_x(const double val) {
  this->x = val;
}

void Vector3f::__set_y(const double val) {
  this->y = val;
}

void Vector3f::__set_z(const double val) {
  this->z = val;
}

uint32_t Vector3f::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Vector3f::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Vector3f");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Vector3f &a, Vector3f &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

Vector3f::Vector3f(const Vector3f& other0) {
  x = other0.x;
  y = other0.y;
  z = other0.z;
  __isset = other0.__isset;
}
Vector3f::Vector3f( Vector3f&& other1) {
  x = std::move(other1.x);
  y = std::move(other1.y);
  z = std::move(other1.z);
  __isset = std::move(other1.__isset);
}
Vector3f& Vector3f::operator=(const Vector3f& other2) {
  x = other2.x;
  y = other2.y;
  z = other2.z;
  __isset = other2.__isset;
  return *this;
}
Vector3f& Vector3f::operator=(Vector3f&& other3) {
  x = std::move(other3.x);
  y = std::move(other3.y);
  z = std::move(other3.z);
  __isset = std::move(other3.__isset);
  return *this;
}

Color3f::~Color3f() throw() {
}


void Color3f::__set_r(const double val) {
  this->r = val;
}

void Color3f::__set_g(const double val) {
  this->g = val;
}

void Color3f::__set_b(const double val) {
  this->b = val;
}

uint32_t Color3f::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->r);
          this->__isset.r = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->g);
          this->__isset.g = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Color3f::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Color3f");

  xfer += oprot->writeFieldBegin("r", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->r);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("g", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->g);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->b);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Color3f &a, Color3f &b) {
  using ::std::swap;
  swap(a.r, b.r);
  swap(a.g, b.g);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

Color3f::Color3f(const Color3f& other4) {
  r = other4.r;
  g = other4.g;
  b = other4.b;
  __isset = other4.__isset;
}
Color3f::Color3f( Color3f&& other5) {
  r = std::move(other5.r);
  g = std::move(other5.g);
  b = std::move(other5.b);
  __isset = std::move(other5.__isset);
}
Color3f& Color3f::operator=(const Color3f& other6) {
  r = other6.r;
  g = other6.g;
  b = other6.b;
  __isset = other6.__isset;
  return *this;
}
Color3f& Color3f::operator=(Color3f&& other7) {
  r = std::move(other7.r);
  g = std::move(other7.g);
  b = std::move(other7.b);
  __isset = std::move(other7.__isset);
  return *this;
}

Matrix4f::~Matrix4f() throw() {
}


void Matrix4f::__set_basis_x(const Vector3f& val) {
  this->basis_x = val;
}

void Matrix4f::__set_basis_y(const Vector3f& val) {
  this->basis_y = val;
}

void Matrix4f::__set_t(const Vector3f& val) {
  this->t = val;
}

void Matrix4f::__set_s(const double val) {
  this->s = val;
}

uint32_t Matrix4f::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->basis_x.read(iprot);
          this->__isset.basis_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->basis_y.read(iprot);
          this->__isset.basis_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->t.read(iprot);
          this->__isset.t = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->s);
          this->__isset.s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Matrix4f::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix4f");

  xfer += oprot->writeFieldBegin("basis_x", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->basis_x.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("basis_y", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->basis_y.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("t", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->t.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix4f &a, Matrix4f &b) {
  using ::std::swap;
  swap(a.basis_x, b.basis_x);
  swap(a.basis_y, b.basis_y);
  swap(a.t, b.t);
  swap(a.s, b.s);
  swap(a.__isset, b.__isset);
}

Matrix4f::Matrix4f(const Matrix4f& other8) {
  basis_x = other8.basis_x;
  basis_y = other8.basis_y;
  t = other8.t;
  s = other8.s;
  __isset = other8.__isset;
}
Matrix4f::Matrix4f( Matrix4f&& other9) {
  basis_x = std::move(other9.basis_x);
  basis_y = std::move(other9.basis_y);
  t = std::move(other9.t);
  s = std::move(other9.s);
  __isset = std::move(other9.__isset);
}
Matrix4f& Matrix4f::operator=(const Matrix4f& other10) {
  basis_x = other10.basis_x;
  basis_y = other10.basis_y;
  t = other10.t;
  s = other10.s;
  __isset = other10.__isset;
  return *this;
}
Matrix4f& Matrix4f::operator=(Matrix4f&& other11) {
  basis_x = std::move(other11.basis_x);
  basis_y = std::move(other11.basis_y);
  t = std::move(other11.t);
  s = std::move(other11.s);
  __isset = std::move(other11.__isset);
  return *this;
}

Viewport::~Viewport() throw() {
}


void Viewport::__set_width(const int32_t val) {
  this->width = val;
}

void Viewport::__set_height(const int32_t val) {
  this->height = val;
}

uint32_t Viewport::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Viewport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Viewport");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Viewport &a, Viewport &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.__isset, b.__isset);
}

Viewport::Viewport(const Viewport& other12) {
  width = other12.width;
  height = other12.height;
  __isset = other12.__isset;
}
Viewport::Viewport( Viewport&& other13) {
  width = std::move(other13.width);
  height = std::move(other13.height);
  __isset = std::move(other13.__isset);
}
Viewport& Viewport::operator=(const Viewport& other14) {
  width = other14.width;
  height = other14.height;
  __isset = other14.__isset;
  return *this;
}
Viewport& Viewport::operator=(Viewport&& other15) {
  width = std::move(other15.width);
  height = std::move(other15.height);
  __isset = std::move(other15.__isset);
  return *this;
}

BoundingBox2i::~BoundingBox2i() throw() {
}


void BoundingBox2i::__set_xmin(const int32_t val) {
  this->xmin = val;
}

void BoundingBox2i::__set_xmax(const int32_t val) {
  this->xmax = val;
}

void BoundingBox2i::__set_ymin(const int32_t val) {
  this->ymin = val;
}

void BoundingBox2i::__set_ymax(const int32_t val) {
  this->ymax = val;
}

uint32_t BoundingBox2i::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xmin);
          this->__isset.xmin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xmax);
          this->__isset.xmax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ymin);
          this->__isset.ymin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ymax);
          this->__isset.ymax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BoundingBox2i::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BoundingBox2i");

  xfer += oprot->writeFieldBegin("xmin", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->xmin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xmax", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->xmax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ymin", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ymin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ymax", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->ymax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BoundingBox2i &a, BoundingBox2i &b) {
  using ::std::swap;
  swap(a.xmin, b.xmin);
  swap(a.xmax, b.xmax);
  swap(a.ymin, b.ymin);
  swap(a.ymax, b.ymax);
  swap(a.__isset, b.__isset);
}

BoundingBox2i::BoundingBox2i(const BoundingBox2i& other16) {
  xmin = other16.xmin;
  xmax = other16.xmax;
  ymin = other16.ymin;
  ymax = other16.ymax;
  __isset = other16.__isset;
}
BoundingBox2i::BoundingBox2i( BoundingBox2i&& other17) {
  xmin = std::move(other17.xmin);
  xmax = std::move(other17.xmax);
  ymin = std::move(other17.ymin);
  ymax = std::move(other17.ymax);
  __isset = std::move(other17.__isset);
}
BoundingBox2i& BoundingBox2i::operator=(const BoundingBox2i& other18) {
  xmin = other18.xmin;
  xmax = other18.xmax;
  ymin = other18.ymin;
  ymax = other18.ymax;
  __isset = other18.__isset;
  return *this;
}
BoundingBox2i& BoundingBox2i::operator=(BoundingBox2i&& other19) {
  xmin = std::move(other19.xmin);
  xmax = std::move(other19.xmax);
  ymin = std::move(other19.ymin);
  ymax = std::move(other19.ymax);
  __isset = std::move(other19.__isset);
  return *this;
}

BoundingBox3f::~BoundingBox3f() throw() {
}


void BoundingBox3f::__set_xmin(const double val) {
  this->xmin = val;
}

void BoundingBox3f::__set_xmax(const double val) {
  this->xmax = val;
}

void BoundingBox3f::__set_ymin(const double val) {
  this->ymin = val;
}

void BoundingBox3f::__set_ymax(const double val) {
  this->ymax = val;
}

void BoundingBox3f::__set_zmin(const double val) {
  this->zmin = val;
}

void BoundingBox3f::__set_zmax(const double val) {
  this->zmax = val;
}

uint32_t BoundingBox3f::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xmin);
          this->__isset.xmin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xmax);
          this->__isset.xmax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ymin);
          this->__isset.ymin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ymax);
          this->__isset.ymax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->zmin);
          this->__isset.zmin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->zmax);
          this->__isset.zmax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BoundingBox3f::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BoundingBox3f");

  xfer += oprot->writeFieldBegin("xmin", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->xmin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xmax", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->xmax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ymin", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->ymin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ymax", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->ymax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zmin", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->zmin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zmax", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->zmax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BoundingBox3f &a, BoundingBox3f &b) {
  using ::std::swap;
  swap(a.xmin, b.xmin);
  swap(a.xmax, b.xmax);
  swap(a.ymin, b.ymin);
  swap(a.ymax, b.ymax);
  swap(a.zmin, b.zmin);
  swap(a.zmax, b.zmax);
  swap(a.__isset, b.__isset);
}

BoundingBox3f::BoundingBox3f(const BoundingBox3f& other20) {
  xmin = other20.xmin;
  xmax = other20.xmax;
  ymin = other20.ymin;
  ymax = other20.ymax;
  zmin = other20.zmin;
  zmax = other20.zmax;
  __isset = other20.__isset;
}
BoundingBox3f::BoundingBox3f( BoundingBox3f&& other21) {
  xmin = std::move(other21.xmin);
  xmax = std::move(other21.xmax);
  ymin = std::move(other21.ymin);
  ymax = std::move(other21.ymax);
  zmin = std::move(other21.zmin);
  zmax = std::move(other21.zmax);
  __isset = std::move(other21.__isset);
}
BoundingBox3f& BoundingBox3f::operator=(const BoundingBox3f& other22) {
  xmin = other22.xmin;
  xmax = other22.xmax;
  ymin = other22.ymin;
  ymax = other22.ymax;
  zmin = other22.zmin;
  zmax = other22.zmax;
  __isset = other22.__isset;
  return *this;
}
BoundingBox3f& BoundingBox3f::operator=(BoundingBox3f&& other23) {
  xmin = std::move(other23.xmin);
  xmax = std::move(other23.xmax);
  ymin = std::move(other23.ymin);
  ymax = std::move(other23.ymax);
  zmin = std::move(other23.zmin);
  zmax = std::move(other23.zmax);
  __isset = std::move(other23.__isset);
  return *this;
}

DataBuffer::~DataBuffer() throw() {
}


void DataBuffer::__set_format(const DataBufferFormat val) {
  this->format = val;
}

void DataBuffer::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t DataBuffer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->format = (DataBufferFormat)ecast24;
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataBuffer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataBuffer");

  xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataBuffer &a, DataBuffer &b) {
  using ::std::swap;
  swap(a.format, b.format);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

DataBuffer::DataBuffer(const DataBuffer& other25) {
  format = other25.format;
  data = other25.data;
  __isset = other25.__isset;
}
DataBuffer::DataBuffer( DataBuffer&& other26) {
  format = std::move(other26.format);
  data = std::move(other26.data);
  __isset = std::move(other26.__isset);
}
DataBuffer& DataBuffer::operator=(const DataBuffer& other27) {
  format = other27.format;
  data = other27.data;
  __isset = other27.__isset;
  return *this;
}
DataBuffer& DataBuffer::operator=(DataBuffer&& other28) {
  format = std::move(other28.format);
  data = std::move(other28.data);
  __isset = std::move(other28.__isset);
  return *this;
}

FrameID::~FrameID() throw() {
}


void FrameID::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t FrameID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FrameID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FrameID");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FrameID &a, FrameID &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

FrameID::FrameID(const FrameID& other29) {
  id = other29.id;
  __isset = other29.__isset;
}
FrameID::FrameID( FrameID&& other30) {
  id = std::move(other30.id);
  __isset = std::move(other30.__isset);
}
FrameID& FrameID::operator=(const FrameID& other31) {
  id = other31.id;
  __isset = other31.__isset;
  return *this;
}
FrameID& FrameID::operator=(FrameID&& other32) {
  id = std::move(other32.id);
  __isset = std::move(other32.__isset);
  return *this;
}

ImageFragmentBuffers::~ImageFragmentBuffers() throw() {
}


void ImageFragmentBuffers::__set_extents(const Viewport& val) {
  this->extents = val;
}

void ImageFragmentBuffers::__set_pixels(const DataBuffer& val) {
  this->pixels = val;
}

void ImageFragmentBuffers::__set_depth(const DataBuffer& val) {
  this->depth = val;
}

uint32_t ImageFragmentBuffers::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->extents.read(iprot);
          this->__isset.extents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixels.read(iprot);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->depth.read(iprot);
          this->__isset.depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImageFragmentBuffers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImageFragmentBuffers");

  xfer += oprot->writeFieldBegin("extents", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->extents.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pixels.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->depth.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImageFragmentBuffers &a, ImageFragmentBuffers &b) {
  using ::std::swap;
  swap(a.extents, b.extents);
  swap(a.pixels, b.pixels);
  swap(a.depth, b.depth);
  swap(a.__isset, b.__isset);
}

ImageFragmentBuffers::ImageFragmentBuffers(const ImageFragmentBuffers& other33) {
  extents = other33.extents;
  pixels = other33.pixels;
  depth = other33.depth;
  __isset = other33.__isset;
}
ImageFragmentBuffers::ImageFragmentBuffers( ImageFragmentBuffers&& other34) {
  extents = std::move(other34.extents);
  pixels = std::move(other34.pixels);
  depth = std::move(other34.depth);
  __isset = std::move(other34.__isset);
}
ImageFragmentBuffers& ImageFragmentBuffers::operator=(const ImageFragmentBuffers& other35) {
  extents = other35.extents;
  pixels = other35.pixels;
  depth = other35.depth;
  __isset = other35.__isset;
  return *this;
}
ImageFragmentBuffers& ImageFragmentBuffers::operator=(ImageFragmentBuffers&& other36) {
  extents = std::move(other36.extents);
  pixels = std::move(other36.pixels);
  depth = std::move(other36.depth);
  __isset = std::move(other36.__isset);
  return *this;
}

ImageFragmentInfo::~ImageFragmentInfo() throw() {
}


void ImageFragmentInfo::__set_key(const std::string& val) {
  this->key = val;
}

void ImageFragmentInfo::__set_bounds(const BoundingBox2i& val) {
  this->bounds = val;
}

void ImageFragmentInfo::__set_isOpaque(const bool val) {
  this->isOpaque = val;
}

uint32_t ImageFragmentInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bounds.read(iprot);
          this->__isset.bounds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isOpaque);
          this->__isset.isOpaque = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImageFragmentInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImageFragmentInfo");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bounds", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->bounds.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isOpaque", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isOpaque);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImageFragmentInfo &a, ImageFragmentInfo &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.bounds, b.bounds);
  swap(a.isOpaque, b.isOpaque);
  swap(a.__isset, b.__isset);
}

ImageFragmentInfo::ImageFragmentInfo(const ImageFragmentInfo& other37) {
  key = other37.key;
  bounds = other37.bounds;
  isOpaque = other37.isOpaque;
  __isset = other37.__isset;
}
ImageFragmentInfo::ImageFragmentInfo( ImageFragmentInfo&& other38) {
  key = std::move(other38.key);
  bounds = std::move(other38.bounds);
  isOpaque = std::move(other38.isOpaque);
  __isset = std::move(other38.__isset);
}
ImageFragmentInfo& ImageFragmentInfo::operator=(const ImageFragmentInfo& other39) {
  key = other39.key;
  bounds = other39.bounds;
  isOpaque = other39.isOpaque;
  __isset = other39.__isset;
  return *this;
}
ImageFragmentInfo& ImageFragmentInfo::operator=(ImageFragmentInfo&& other40) {
  key = std::move(other40.key);
  bounds = std::move(other40.bounds);
  isOpaque = std::move(other40.isOpaque);
  __isset = std::move(other40.__isset);
  return *this;
}

ImageFragmentList::~ImageFragmentList() throw() {
}


void ImageFragmentList::__set_frame(const FrameID& val) {
  this->frame = val;
}

void ImageFragmentList::__set_fragments(const ImageFragmentInfo_list& val) {
  this->fragments = val;
}

void ImageFragmentList::__set_totalCount(const int32_t val) {
  this->totalCount = val;
}

void ImageFragmentList::__set_accumCount(const int32_t val) {
  this->accumCount = val;
}

uint32_t ImageFragmentList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frame.read(iprot);
          this->__isset.frame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fragments.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->fragments.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->fragments[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fragments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalCount);
          this->__isset.totalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accumCount);
          this->__isset.accumCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImageFragmentList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImageFragmentList");

  xfer += oprot->writeFieldBegin("frame", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->frame.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fragments.size()));
    std::vector<ImageFragmentInfo> ::const_iterator _iter46;
    for (_iter46 = this->fragments.begin(); _iter46 != this->fragments.end(); ++_iter46)
    {
      xfer += (*_iter46).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->totalCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accumCount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->accumCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImageFragmentList &a, ImageFragmentList &b) {
  using ::std::swap;
  swap(a.frame, b.frame);
  swap(a.fragments, b.fragments);
  swap(a.totalCount, b.totalCount);
  swap(a.accumCount, b.accumCount);
  swap(a.__isset, b.__isset);
}

ImageFragmentList::ImageFragmentList(const ImageFragmentList& other47) {
  frame = other47.frame;
  fragments = other47.fragments;
  totalCount = other47.totalCount;
  accumCount = other47.accumCount;
  __isset = other47.__isset;
}
ImageFragmentList::ImageFragmentList( ImageFragmentList&& other48) {
  frame = std::move(other48.frame);
  fragments = std::move(other48.fragments);
  totalCount = std::move(other48.totalCount);
  accumCount = std::move(other48.accumCount);
  __isset = std::move(other48.__isset);
}
ImageFragmentList& ImageFragmentList::operator=(const ImageFragmentList& other49) {
  frame = other49.frame;
  fragments = other49.fragments;
  totalCount = other49.totalCount;
  accumCount = other49.accumCount;
  __isset = other49.__isset;
  return *this;
}
ImageFragmentList& ImageFragmentList::operator=(ImageFragmentList&& other50) {
  frame = std::move(other50.frame);
  fragments = std::move(other50.fragments);
  totalCount = std::move(other50.totalCount);
  accumCount = std::move(other50.accumCount);
  __isset = std::move(other50.__isset);
  return *this;
}
} // namespace

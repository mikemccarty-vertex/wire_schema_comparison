// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schemata/RenderJob.proto

#ifndef PROTOBUF_schemata_2fRenderJob_2eproto__INCLUDED
#define PROTOBUF_schemata_2fRenderJob_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_schemata_2fRenderJob_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsVector3fImpl();
void InitDefaultsVector3f();
void InitDefaultsColor3fImpl();
void InitDefaultsColor3f();
void InitDefaultsMatrix4fImpl();
void InitDefaultsMatrix4f();
void InitDefaultsViewportImpl();
void InitDefaultsViewport();
void InitDefaultsBoundingBox2iImpl();
void InitDefaultsBoundingBox2i();
void InitDefaultsBoundingBox3fImpl();
void InitDefaultsBoundingBox3f();
void InitDefaultsDataBufferImpl();
void InitDefaultsDataBuffer();
void InitDefaultsFrameIDImpl();
void InitDefaultsFrameID();
void InitDefaultsImageFragmentBuffersImpl();
void InitDefaultsImageFragmentBuffers();
void InitDefaultsImageFragmentInfoImpl();
void InitDefaultsImageFragmentInfo();
void InitDefaultsImageFragmentListImpl();
void InitDefaultsImageFragmentList();
inline void InitDefaults() {
  InitDefaultsVector3f();
  InitDefaultsColor3f();
  InitDefaultsMatrix4f();
  InitDefaultsViewport();
  InitDefaultsBoundingBox2i();
  InitDefaultsBoundingBox3f();
  InitDefaultsDataBuffer();
  InitDefaultsFrameID();
  InitDefaultsImageFragmentBuffers();
  InitDefaultsImageFragmentInfo();
  InitDefaultsImageFragmentList();
}
}  // namespace protobuf_schemata_2fRenderJob_2eproto
namespace speedracer_proto {
class BoundingBox2i;
class BoundingBox2iDefaultTypeInternal;
extern BoundingBox2iDefaultTypeInternal _BoundingBox2i_default_instance_;
class BoundingBox3f;
class BoundingBox3fDefaultTypeInternal;
extern BoundingBox3fDefaultTypeInternal _BoundingBox3f_default_instance_;
class Color3f;
class Color3fDefaultTypeInternal;
extern Color3fDefaultTypeInternal _Color3f_default_instance_;
class DataBuffer;
class DataBufferDefaultTypeInternal;
extern DataBufferDefaultTypeInternal _DataBuffer_default_instance_;
class FrameID;
class FrameIDDefaultTypeInternal;
extern FrameIDDefaultTypeInternal _FrameID_default_instance_;
class ImageFragmentBuffers;
class ImageFragmentBuffersDefaultTypeInternal;
extern ImageFragmentBuffersDefaultTypeInternal _ImageFragmentBuffers_default_instance_;
class ImageFragmentInfo;
class ImageFragmentInfoDefaultTypeInternal;
extern ImageFragmentInfoDefaultTypeInternal _ImageFragmentInfo_default_instance_;
class ImageFragmentList;
class ImageFragmentListDefaultTypeInternal;
extern ImageFragmentListDefaultTypeInternal _ImageFragmentList_default_instance_;
class Matrix4f;
class Matrix4fDefaultTypeInternal;
extern Matrix4fDefaultTypeInternal _Matrix4f_default_instance_;
class Vector3f;
class Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
class Viewport;
class ViewportDefaultTypeInternal;
extern ViewportDefaultTypeInternal _Viewport_default_instance_;
}  // namespace speedracer_proto
namespace speedracer_proto {

enum DataBufferFormat {
  BUFFER_NONE = 0,
  BUFFER_RGB_8 = 1,
  BUFFER_RGBA_8 = 2,
  BUFFER_UINT_16_LE = 3,
  BUFFER_UINT_16_BE = 4,
  BUFFER_FLOAT_32_LE = 5,
  DataBufferFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataBufferFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataBufferFormat_IsValid(int value);
const DataBufferFormat DataBufferFormat_MIN = BUFFER_NONE;
const DataBufferFormat DataBufferFormat_MAX = BUFFER_FLOAT_32_LE;
const int DataBufferFormat_ARRAYSIZE = DataBufferFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataBufferFormat_descriptor();
inline const ::std::string& DataBufferFormat_Name(DataBufferFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataBufferFormat_descriptor(), value);
}
inline bool DataBufferFormat_Parse(
    const ::std::string& name, DataBufferFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataBufferFormat>(
    DataBufferFormat_descriptor(), name, value);
}
// ===================================================================

class Vector3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.Vector3f) */ {
 public:
  Vector3f();
  virtual ~Vector3f();

  Vector3f(const Vector3f& from);

  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3f(Vector3f&& from) noexcept
    : Vector3f() {
    *this = ::std::move(from);
  }

  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
               &_Vector3f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Vector3f* other);
  friend void swap(Vector3f& a, Vector3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3f* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3f& from);
  void MergeFrom(const Vector3f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.Vector3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsVector3fImpl();
};
// -------------------------------------------------------------------

class Color3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.Color3f) */ {
 public:
  Color3f();
  virtual ~Color3f();

  Color3f(const Color3f& from);

  inline Color3f& operator=(const Color3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Color3f(Color3f&& from) noexcept
    : Color3f() {
    *this = ::std::move(from);
  }

  inline Color3f& operator=(Color3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Color3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color3f* internal_default_instance() {
    return reinterpret_cast<const Color3f*>(
               &_Color3f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Color3f* other);
  friend void swap(Color3f& a, Color3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Color3f* New() const PROTOBUF_FINAL { return New(NULL); }

  Color3f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Color3f& from);
  void MergeFrom(const Color3f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Color3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float r = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // float g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.Color3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float r_;
  float g_;
  float b_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsColor3fImpl();
};
// -------------------------------------------------------------------

class Matrix4f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.Matrix4f) */ {
 public:
  Matrix4f();
  virtual ~Matrix4f();

  Matrix4f(const Matrix4f& from);

  inline Matrix4f& operator=(const Matrix4f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Matrix4f(Matrix4f&& from) noexcept
    : Matrix4f() {
    *this = ::std::move(from);
  }

  inline Matrix4f& operator=(Matrix4f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Matrix4f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Matrix4f* internal_default_instance() {
    return reinterpret_cast<const Matrix4f*>(
               &_Matrix4f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Matrix4f* other);
  friend void swap(Matrix4f& a, Matrix4f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Matrix4f* New() const PROTOBUF_FINAL { return New(NULL); }

  Matrix4f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Matrix4f& from);
  void MergeFrom(const Matrix4f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Matrix4f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speedracer_proto.Vector3f basis_x = 1;
  bool has_basis_x() const;
  void clear_basis_x();
  static const int kBasisXFieldNumber = 1;
  const ::speedracer_proto::Vector3f& basis_x() const;
  ::speedracer_proto::Vector3f* release_basis_x();
  ::speedracer_proto::Vector3f* mutable_basis_x();
  void set_allocated_basis_x(::speedracer_proto::Vector3f* basis_x);

  // .speedracer_proto.Vector3f basis_y = 2;
  bool has_basis_y() const;
  void clear_basis_y();
  static const int kBasisYFieldNumber = 2;
  const ::speedracer_proto::Vector3f& basis_y() const;
  ::speedracer_proto::Vector3f* release_basis_y();
  ::speedracer_proto::Vector3f* mutable_basis_y();
  void set_allocated_basis_y(::speedracer_proto::Vector3f* basis_y);

  // .speedracer_proto.Vector3f t = 3;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 3;
  const ::speedracer_proto::Vector3f& t() const;
  ::speedracer_proto::Vector3f* release_t();
  ::speedracer_proto::Vector3f* mutable_t();
  void set_allocated_t(::speedracer_proto::Vector3f* t);

  // float s = 4;
  void clear_s();
  static const int kSFieldNumber = 4;
  float s() const;
  void set_s(float value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.Matrix4f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::speedracer_proto::Vector3f* basis_x_;
  ::speedracer_proto::Vector3f* basis_y_;
  ::speedracer_proto::Vector3f* t_;
  float s_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsMatrix4fImpl();
};
// -------------------------------------------------------------------

class Viewport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.Viewport) */ {
 public:
  Viewport();
  virtual ~Viewport();

  Viewport(const Viewport& from);

  inline Viewport& operator=(const Viewport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Viewport(Viewport&& from) noexcept
    : Viewport() {
    *this = ::std::move(from);
  }

  inline Viewport& operator=(Viewport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Viewport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Viewport* internal_default_instance() {
    return reinterpret_cast<const Viewport*>(
               &_Viewport_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Viewport* other);
  friend void swap(Viewport& a, Viewport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Viewport* New() const PROTOBUF_FINAL { return New(NULL); }

  Viewport* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Viewport& from);
  void MergeFrom(const Viewport& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Viewport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.Viewport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsViewportImpl();
};
// -------------------------------------------------------------------

class BoundingBox2i : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.BoundingBox2i) */ {
 public:
  BoundingBox2i();
  virtual ~BoundingBox2i();

  BoundingBox2i(const BoundingBox2i& from);

  inline BoundingBox2i& operator=(const BoundingBox2i& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundingBox2i(BoundingBox2i&& from) noexcept
    : BoundingBox2i() {
    *this = ::std::move(from);
  }

  inline BoundingBox2i& operator=(BoundingBox2i&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox2i& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox2i* internal_default_instance() {
    return reinterpret_cast<const BoundingBox2i*>(
               &_BoundingBox2i_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BoundingBox2i* other);
  friend void swap(BoundingBox2i& a, BoundingBox2i& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox2i* New() const PROTOBUF_FINAL { return New(NULL); }

  BoundingBox2i* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoundingBox2i& from);
  void MergeFrom(const BoundingBox2i& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoundingBox2i* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 xmin = 1;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  ::google::protobuf::int32 xmin() const;
  void set_xmin(::google::protobuf::int32 value);

  // int32 xmax = 2;
  void clear_xmax();
  static const int kXmaxFieldNumber = 2;
  ::google::protobuf::int32 xmax() const;
  void set_xmax(::google::protobuf::int32 value);

  // int32 ymin = 3;
  void clear_ymin();
  static const int kYminFieldNumber = 3;
  ::google::protobuf::int32 ymin() const;
  void set_ymin(::google::protobuf::int32 value);

  // int32 ymax = 4;
  void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  ::google::protobuf::int32 ymax() const;
  void set_ymax(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.BoundingBox2i)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 xmin_;
  ::google::protobuf::int32 xmax_;
  ::google::protobuf::int32 ymin_;
  ::google::protobuf::int32 ymax_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsBoundingBox2iImpl();
};
// -------------------------------------------------------------------

class BoundingBox3f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.BoundingBox3f) */ {
 public:
  BoundingBox3f();
  virtual ~BoundingBox3f();

  BoundingBox3f(const BoundingBox3f& from);

  inline BoundingBox3f& operator=(const BoundingBox3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundingBox3f(BoundingBox3f&& from) noexcept
    : BoundingBox3f() {
    *this = ::std::move(from);
  }

  inline BoundingBox3f& operator=(BoundingBox3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox3f* internal_default_instance() {
    return reinterpret_cast<const BoundingBox3f*>(
               &_BoundingBox3f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(BoundingBox3f* other);
  friend void swap(BoundingBox3f& a, BoundingBox3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox3f* New() const PROTOBUF_FINAL { return New(NULL); }

  BoundingBox3f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoundingBox3f& from);
  void MergeFrom(const BoundingBox3f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoundingBox3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float xmin = 1;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  float xmin() const;
  void set_xmin(float value);

  // float xmax = 2;
  void clear_xmax();
  static const int kXmaxFieldNumber = 2;
  float xmax() const;
  void set_xmax(float value);

  // float ymin = 3;
  void clear_ymin();
  static const int kYminFieldNumber = 3;
  float ymin() const;
  void set_ymin(float value);

  // float ymax = 4;
  void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  float ymax() const;
  void set_ymax(float value);

  // float zmin = 5;
  void clear_zmin();
  static const int kZminFieldNumber = 5;
  float zmin() const;
  void set_zmin(float value);

  // float zmax = 6;
  void clear_zmax();
  static const int kZmaxFieldNumber = 6;
  float zmax() const;
  void set_zmax(float value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.BoundingBox3f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float xmin_;
  float xmax_;
  float ymin_;
  float ymax_;
  float zmin_;
  float zmax_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsBoundingBox3fImpl();
};
// -------------------------------------------------------------------

class DataBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.DataBuffer) */ {
 public:
  DataBuffer();
  virtual ~DataBuffer();

  DataBuffer(const DataBuffer& from);

  inline DataBuffer& operator=(const DataBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataBuffer(DataBuffer&& from) noexcept
    : DataBuffer() {
    *this = ::std::move(from);
  }

  inline DataBuffer& operator=(DataBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataBuffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataBuffer* internal_default_instance() {
    return reinterpret_cast<const DataBuffer*>(
               &_DataBuffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DataBuffer* other);
  friend void swap(DataBuffer& a, DataBuffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  DataBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataBuffer& from);
  void MergeFrom(const DataBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .speedracer_proto.DataBufferFormat format = 1;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::speedracer_proto::DataBufferFormat format() const;
  void set_format(::speedracer_proto::DataBufferFormat value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.DataBuffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int format_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsDataBufferImpl();
};
// -------------------------------------------------------------------

class FrameID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.FrameID) */ {
 public:
  FrameID();
  virtual ~FrameID();

  FrameID(const FrameID& from);

  inline FrameID& operator=(const FrameID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameID(FrameID&& from) noexcept
    : FrameID() {
    *this = ::std::move(from);
  }

  inline FrameID& operator=(FrameID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameID* internal_default_instance() {
    return reinterpret_cast<const FrameID*>(
               &_FrameID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FrameID* other);
  friend void swap(FrameID& a, FrameID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameID* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameID& from);
  void MergeFrom(const FrameID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:speedracer_proto.FrameID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsFrameIDImpl();
};
// -------------------------------------------------------------------

class ImageFragmentBuffers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.ImageFragmentBuffers) */ {
 public:
  ImageFragmentBuffers();
  virtual ~ImageFragmentBuffers();

  ImageFragmentBuffers(const ImageFragmentBuffers& from);

  inline ImageFragmentBuffers& operator=(const ImageFragmentBuffers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFragmentBuffers(ImageFragmentBuffers&& from) noexcept
    : ImageFragmentBuffers() {
    *this = ::std::move(from);
  }

  inline ImageFragmentBuffers& operator=(ImageFragmentBuffers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFragmentBuffers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFragmentBuffers* internal_default_instance() {
    return reinterpret_cast<const ImageFragmentBuffers*>(
               &_ImageFragmentBuffers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ImageFragmentBuffers* other);
  friend void swap(ImageFragmentBuffers& a, ImageFragmentBuffers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFragmentBuffers* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFragmentBuffers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFragmentBuffers& from);
  void MergeFrom(const ImageFragmentBuffers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFragmentBuffers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speedracer_proto.Viewport extents = 1;
  bool has_extents() const;
  void clear_extents();
  static const int kExtentsFieldNumber = 1;
  const ::speedracer_proto::Viewport& extents() const;
  ::speedracer_proto::Viewport* release_extents();
  ::speedracer_proto::Viewport* mutable_extents();
  void set_allocated_extents(::speedracer_proto::Viewport* extents);

  // .speedracer_proto.DataBuffer pixels = 2;
  bool has_pixels() const;
  void clear_pixels();
  static const int kPixelsFieldNumber = 2;
  const ::speedracer_proto::DataBuffer& pixels() const;
  ::speedracer_proto::DataBuffer* release_pixels();
  ::speedracer_proto::DataBuffer* mutable_pixels();
  void set_allocated_pixels(::speedracer_proto::DataBuffer* pixels);

  // .speedracer_proto.DataBuffer depth = 3;
  bool has_depth() const;
  void clear_depth();
  static const int kDepthFieldNumber = 3;
  const ::speedracer_proto::DataBuffer& depth() const;
  ::speedracer_proto::DataBuffer* release_depth();
  ::speedracer_proto::DataBuffer* mutable_depth();
  void set_allocated_depth(::speedracer_proto::DataBuffer* depth);

  // @@protoc_insertion_point(class_scope:speedracer_proto.ImageFragmentBuffers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::speedracer_proto::Viewport* extents_;
  ::speedracer_proto::DataBuffer* pixels_;
  ::speedracer_proto::DataBuffer* depth_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsImageFragmentBuffersImpl();
};
// -------------------------------------------------------------------

class ImageFragmentInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.ImageFragmentInfo) */ {
 public:
  ImageFragmentInfo();
  virtual ~ImageFragmentInfo();

  ImageFragmentInfo(const ImageFragmentInfo& from);

  inline ImageFragmentInfo& operator=(const ImageFragmentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFragmentInfo(ImageFragmentInfo&& from) noexcept
    : ImageFragmentInfo() {
    *this = ::std::move(from);
  }

  inline ImageFragmentInfo& operator=(ImageFragmentInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFragmentInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFragmentInfo* internal_default_instance() {
    return reinterpret_cast<const ImageFragmentInfo*>(
               &_ImageFragmentInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ImageFragmentInfo* other);
  friend void swap(ImageFragmentInfo& a, ImageFragmentInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFragmentInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFragmentInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFragmentInfo& from);
  void MergeFrom(const ImageFragmentInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFragmentInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .speedracer_proto.BoundingBox2i bounds = 2;
  bool has_bounds() const;
  void clear_bounds();
  static const int kBoundsFieldNumber = 2;
  const ::speedracer_proto::BoundingBox2i& bounds() const;
  ::speedracer_proto::BoundingBox2i* release_bounds();
  ::speedracer_proto::BoundingBox2i* mutable_bounds();
  void set_allocated_bounds(::speedracer_proto::BoundingBox2i* bounds);

  // bool isOpaque = 3;
  void clear_isopaque();
  static const int kIsOpaqueFieldNumber = 3;
  bool isopaque() const;
  void set_isopaque(bool value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.ImageFragmentInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::speedracer_proto::BoundingBox2i* bounds_;
  bool isopaque_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsImageFragmentInfoImpl();
};
// -------------------------------------------------------------------

class ImageFragmentList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speedracer_proto.ImageFragmentList) */ {
 public:
  ImageFragmentList();
  virtual ~ImageFragmentList();

  ImageFragmentList(const ImageFragmentList& from);

  inline ImageFragmentList& operator=(const ImageFragmentList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageFragmentList(ImageFragmentList&& from) noexcept
    : ImageFragmentList() {
    *this = ::std::move(from);
  }

  inline ImageFragmentList& operator=(ImageFragmentList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFragmentList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFragmentList* internal_default_instance() {
    return reinterpret_cast<const ImageFragmentList*>(
               &_ImageFragmentList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ImageFragmentList* other);
  friend void swap(ImageFragmentList& a, ImageFragmentList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageFragmentList* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageFragmentList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageFragmentList& from);
  void MergeFrom(const ImageFragmentList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageFragmentList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .speedracer_proto.ImageFragmentInfo fragments = 2;
  int fragments_size() const;
  void clear_fragments();
  static const int kFragmentsFieldNumber = 2;
  const ::speedracer_proto::ImageFragmentInfo& fragments(int index) const;
  ::speedracer_proto::ImageFragmentInfo* mutable_fragments(int index);
  ::speedracer_proto::ImageFragmentInfo* add_fragments();
  ::google::protobuf::RepeatedPtrField< ::speedracer_proto::ImageFragmentInfo >*
      mutable_fragments();
  const ::google::protobuf::RepeatedPtrField< ::speedracer_proto::ImageFragmentInfo >&
      fragments() const;

  // .speedracer_proto.FrameID frame = 1;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 1;
  const ::speedracer_proto::FrameID& frame() const;
  ::speedracer_proto::FrameID* release_frame();
  ::speedracer_proto::FrameID* mutable_frame();
  void set_allocated_frame(::speedracer_proto::FrameID* frame);

  // int32 totalCount = 3;
  void clear_totalcount();
  static const int kTotalCountFieldNumber = 3;
  ::google::protobuf::int32 totalcount() const;
  void set_totalcount(::google::protobuf::int32 value);

  // int32 accumCount = 4;
  void clear_accumcount();
  static const int kAccumCountFieldNumber = 4;
  ::google::protobuf::int32 accumcount() const;
  void set_accumcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speedracer_proto.ImageFragmentList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::speedracer_proto::ImageFragmentInfo > fragments_;
  ::speedracer_proto::FrameID* frame_;
  ::google::protobuf::int32 totalcount_;
  ::google::protobuf::int32 accumcount_;
  mutable int _cached_size_;
  friend struct ::protobuf_schemata_2fRenderJob_2eproto::TableStruct;
  friend void ::protobuf_schemata_2fRenderJob_2eproto::InitDefaultsImageFragmentListImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3f

// float x = 1;
inline void Vector3f::clear_x() {
  x_ = 0;
}
inline float Vector3f::x() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Vector3f.x)
  return x_;
}
inline void Vector3f::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Vector3f.x)
}

// float y = 2;
inline void Vector3f::clear_y() {
  y_ = 0;
}
inline float Vector3f::y() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Vector3f.y)
  return y_;
}
inline void Vector3f::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Vector3f.y)
}

// float z = 3;
inline void Vector3f::clear_z() {
  z_ = 0;
}
inline float Vector3f::z() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Vector3f.z)
  return z_;
}
inline void Vector3f::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Vector3f.z)
}

// -------------------------------------------------------------------

// Color3f

// float r = 1;
inline void Color3f::clear_r() {
  r_ = 0;
}
inline float Color3f::r() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Color3f.r)
  return r_;
}
inline void Color3f::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Color3f.r)
}

// float g = 2;
inline void Color3f::clear_g() {
  g_ = 0;
}
inline float Color3f::g() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Color3f.g)
  return g_;
}
inline void Color3f::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Color3f.g)
}

// float b = 3;
inline void Color3f::clear_b() {
  b_ = 0;
}
inline float Color3f::b() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Color3f.b)
  return b_;
}
inline void Color3f::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Color3f.b)
}

// -------------------------------------------------------------------

// Matrix4f

// .speedracer_proto.Vector3f basis_x = 1;
inline bool Matrix4f::has_basis_x() const {
  return this != internal_default_instance() && basis_x_ != NULL;
}
inline void Matrix4f::clear_basis_x() {
  if (GetArenaNoVirtual() == NULL && basis_x_ != NULL) {
    delete basis_x_;
  }
  basis_x_ = NULL;
}
inline const ::speedracer_proto::Vector3f& Matrix4f::basis_x() const {
  const ::speedracer_proto::Vector3f* p = basis_x_;
  // @@protoc_insertion_point(field_get:speedracer_proto.Matrix4f.basis_x)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::Vector3f*>(
      &::speedracer_proto::_Vector3f_default_instance_);
}
inline ::speedracer_proto::Vector3f* Matrix4f::release_basis_x() {
  // @@protoc_insertion_point(field_release:speedracer_proto.Matrix4f.basis_x)
  
  ::speedracer_proto::Vector3f* temp = basis_x_;
  basis_x_ = NULL;
  return temp;
}
inline ::speedracer_proto::Vector3f* Matrix4f::mutable_basis_x() {
  
  if (basis_x_ == NULL) {
    basis_x_ = new ::speedracer_proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.Matrix4f.basis_x)
  return basis_x_;
}
inline void Matrix4f::set_allocated_basis_x(::speedracer_proto::Vector3f* basis_x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basis_x_;
  }
  if (basis_x) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basis_x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basis_x, submessage_arena);
    }
    
  } else {
    
  }
  basis_x_ = basis_x;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.Matrix4f.basis_x)
}

// .speedracer_proto.Vector3f basis_y = 2;
inline bool Matrix4f::has_basis_y() const {
  return this != internal_default_instance() && basis_y_ != NULL;
}
inline void Matrix4f::clear_basis_y() {
  if (GetArenaNoVirtual() == NULL && basis_y_ != NULL) {
    delete basis_y_;
  }
  basis_y_ = NULL;
}
inline const ::speedracer_proto::Vector3f& Matrix4f::basis_y() const {
  const ::speedracer_proto::Vector3f* p = basis_y_;
  // @@protoc_insertion_point(field_get:speedracer_proto.Matrix4f.basis_y)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::Vector3f*>(
      &::speedracer_proto::_Vector3f_default_instance_);
}
inline ::speedracer_proto::Vector3f* Matrix4f::release_basis_y() {
  // @@protoc_insertion_point(field_release:speedracer_proto.Matrix4f.basis_y)
  
  ::speedracer_proto::Vector3f* temp = basis_y_;
  basis_y_ = NULL;
  return temp;
}
inline ::speedracer_proto::Vector3f* Matrix4f::mutable_basis_y() {
  
  if (basis_y_ == NULL) {
    basis_y_ = new ::speedracer_proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.Matrix4f.basis_y)
  return basis_y_;
}
inline void Matrix4f::set_allocated_basis_y(::speedracer_proto::Vector3f* basis_y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basis_y_;
  }
  if (basis_y) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basis_y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basis_y, submessage_arena);
    }
    
  } else {
    
  }
  basis_y_ = basis_y;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.Matrix4f.basis_y)
}

// .speedracer_proto.Vector3f t = 3;
inline bool Matrix4f::has_t() const {
  return this != internal_default_instance() && t_ != NULL;
}
inline void Matrix4f::clear_t() {
  if (GetArenaNoVirtual() == NULL && t_ != NULL) {
    delete t_;
  }
  t_ = NULL;
}
inline const ::speedracer_proto::Vector3f& Matrix4f::t() const {
  const ::speedracer_proto::Vector3f* p = t_;
  // @@protoc_insertion_point(field_get:speedracer_proto.Matrix4f.t)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::Vector3f*>(
      &::speedracer_proto::_Vector3f_default_instance_);
}
inline ::speedracer_proto::Vector3f* Matrix4f::release_t() {
  // @@protoc_insertion_point(field_release:speedracer_proto.Matrix4f.t)
  
  ::speedracer_proto::Vector3f* temp = t_;
  t_ = NULL;
  return temp;
}
inline ::speedracer_proto::Vector3f* Matrix4f::mutable_t() {
  
  if (t_ == NULL) {
    t_ = new ::speedracer_proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.Matrix4f.t)
  return t_;
}
inline void Matrix4f::set_allocated_t(::speedracer_proto::Vector3f* t) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete t_;
  }
  if (t) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      t = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.Matrix4f.t)
}

// float s = 4;
inline void Matrix4f::clear_s() {
  s_ = 0;
}
inline float Matrix4f::s() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Matrix4f.s)
  return s_;
}
inline void Matrix4f::set_s(float value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Matrix4f.s)
}

// -------------------------------------------------------------------

// Viewport

// int32 width = 1;
inline void Viewport::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 Viewport::width() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Viewport.width)
  return width_;
}
inline void Viewport::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Viewport.width)
}

// int32 height = 2;
inline void Viewport::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Viewport::height() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.Viewport.height)
  return height_;
}
inline void Viewport::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.Viewport.height)
}

// -------------------------------------------------------------------

// BoundingBox2i

// int32 xmin = 1;
inline void BoundingBox2i::clear_xmin() {
  xmin_ = 0;
}
inline ::google::protobuf::int32 BoundingBox2i::xmin() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox2i.xmin)
  return xmin_;
}
inline void BoundingBox2i::set_xmin(::google::protobuf::int32 value) {
  
  xmin_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox2i.xmin)
}

// int32 xmax = 2;
inline void BoundingBox2i::clear_xmax() {
  xmax_ = 0;
}
inline ::google::protobuf::int32 BoundingBox2i::xmax() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox2i.xmax)
  return xmax_;
}
inline void BoundingBox2i::set_xmax(::google::protobuf::int32 value) {
  
  xmax_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox2i.xmax)
}

// int32 ymin = 3;
inline void BoundingBox2i::clear_ymin() {
  ymin_ = 0;
}
inline ::google::protobuf::int32 BoundingBox2i::ymin() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox2i.ymin)
  return ymin_;
}
inline void BoundingBox2i::set_ymin(::google::protobuf::int32 value) {
  
  ymin_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox2i.ymin)
}

// int32 ymax = 4;
inline void BoundingBox2i::clear_ymax() {
  ymax_ = 0;
}
inline ::google::protobuf::int32 BoundingBox2i::ymax() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox2i.ymax)
  return ymax_;
}
inline void BoundingBox2i::set_ymax(::google::protobuf::int32 value) {
  
  ymax_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox2i.ymax)
}

// -------------------------------------------------------------------

// BoundingBox3f

// float xmin = 1;
inline void BoundingBox3f::clear_xmin() {
  xmin_ = 0;
}
inline float BoundingBox3f::xmin() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.xmin)
  return xmin_;
}
inline void BoundingBox3f::set_xmin(float value) {
  
  xmin_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.xmin)
}

// float xmax = 2;
inline void BoundingBox3f::clear_xmax() {
  xmax_ = 0;
}
inline float BoundingBox3f::xmax() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.xmax)
  return xmax_;
}
inline void BoundingBox3f::set_xmax(float value) {
  
  xmax_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.xmax)
}

// float ymin = 3;
inline void BoundingBox3f::clear_ymin() {
  ymin_ = 0;
}
inline float BoundingBox3f::ymin() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.ymin)
  return ymin_;
}
inline void BoundingBox3f::set_ymin(float value) {
  
  ymin_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.ymin)
}

// float ymax = 4;
inline void BoundingBox3f::clear_ymax() {
  ymax_ = 0;
}
inline float BoundingBox3f::ymax() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.ymax)
  return ymax_;
}
inline void BoundingBox3f::set_ymax(float value) {
  
  ymax_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.ymax)
}

// float zmin = 5;
inline void BoundingBox3f::clear_zmin() {
  zmin_ = 0;
}
inline float BoundingBox3f::zmin() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.zmin)
  return zmin_;
}
inline void BoundingBox3f::set_zmin(float value) {
  
  zmin_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.zmin)
}

// float zmax = 6;
inline void BoundingBox3f::clear_zmax() {
  zmax_ = 0;
}
inline float BoundingBox3f::zmax() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.BoundingBox3f.zmax)
  return zmax_;
}
inline void BoundingBox3f::set_zmax(float value) {
  
  zmax_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.BoundingBox3f.zmax)
}

// -------------------------------------------------------------------

// DataBuffer

// .speedracer_proto.DataBufferFormat format = 1;
inline void DataBuffer::clear_format() {
  format_ = 0;
}
inline ::speedracer_proto::DataBufferFormat DataBuffer::format() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.DataBuffer.format)
  return static_cast< ::speedracer_proto::DataBufferFormat >(format_);
}
inline void DataBuffer::set_format(::speedracer_proto::DataBufferFormat value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.DataBuffer.format)
}

// bytes data = 2;
inline void DataBuffer::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataBuffer::data() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.DataBuffer.data)
  return data_.GetNoArena();
}
inline void DataBuffer::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speedracer_proto.DataBuffer.data)
}
#if LANG_CXX11
inline void DataBuffer::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speedracer_proto.DataBuffer.data)
}
#endif
inline void DataBuffer::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speedracer_proto.DataBuffer.data)
}
inline void DataBuffer::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speedracer_proto.DataBuffer.data)
}
inline ::std::string* DataBuffer::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:speedracer_proto.DataBuffer.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataBuffer::release_data() {
  // @@protoc_insertion_point(field_release:speedracer_proto.DataBuffer.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataBuffer::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.DataBuffer.data)
}

// -------------------------------------------------------------------

// FrameID

// string id = 1;
inline void FrameID::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FrameID::id() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.FrameID.id)
  return id_.GetNoArena();
}
inline void FrameID::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speedracer_proto.FrameID.id)
}
#if LANG_CXX11
inline void FrameID::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speedracer_proto.FrameID.id)
}
#endif
inline void FrameID::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speedracer_proto.FrameID.id)
}
inline void FrameID::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speedracer_proto.FrameID.id)
}
inline ::std::string* FrameID::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:speedracer_proto.FrameID.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameID::release_id() {
  // @@protoc_insertion_point(field_release:speedracer_proto.FrameID.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameID::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.FrameID.id)
}

// -------------------------------------------------------------------

// ImageFragmentBuffers

// .speedracer_proto.Viewport extents = 1;
inline bool ImageFragmentBuffers::has_extents() const {
  return this != internal_default_instance() && extents_ != NULL;
}
inline void ImageFragmentBuffers::clear_extents() {
  if (GetArenaNoVirtual() == NULL && extents_ != NULL) {
    delete extents_;
  }
  extents_ = NULL;
}
inline const ::speedracer_proto::Viewport& ImageFragmentBuffers::extents() const {
  const ::speedracer_proto::Viewport* p = extents_;
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentBuffers.extents)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::Viewport*>(
      &::speedracer_proto::_Viewport_default_instance_);
}
inline ::speedracer_proto::Viewport* ImageFragmentBuffers::release_extents() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentBuffers.extents)
  
  ::speedracer_proto::Viewport* temp = extents_;
  extents_ = NULL;
  return temp;
}
inline ::speedracer_proto::Viewport* ImageFragmentBuffers::mutable_extents() {
  
  if (extents_ == NULL) {
    extents_ = new ::speedracer_proto::Viewport;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentBuffers.extents)
  return extents_;
}
inline void ImageFragmentBuffers::set_allocated_extents(::speedracer_proto::Viewport* extents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete extents_;
  }
  if (extents) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      extents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extents, submessage_arena);
    }
    
  } else {
    
  }
  extents_ = extents;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentBuffers.extents)
}

// .speedracer_proto.DataBuffer pixels = 2;
inline bool ImageFragmentBuffers::has_pixels() const {
  return this != internal_default_instance() && pixels_ != NULL;
}
inline void ImageFragmentBuffers::clear_pixels() {
  if (GetArenaNoVirtual() == NULL && pixels_ != NULL) {
    delete pixels_;
  }
  pixels_ = NULL;
}
inline const ::speedracer_proto::DataBuffer& ImageFragmentBuffers::pixels() const {
  const ::speedracer_proto::DataBuffer* p = pixels_;
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentBuffers.pixels)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::DataBuffer*>(
      &::speedracer_proto::_DataBuffer_default_instance_);
}
inline ::speedracer_proto::DataBuffer* ImageFragmentBuffers::release_pixels() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentBuffers.pixels)
  
  ::speedracer_proto::DataBuffer* temp = pixels_;
  pixels_ = NULL;
  return temp;
}
inline ::speedracer_proto::DataBuffer* ImageFragmentBuffers::mutable_pixels() {
  
  if (pixels_ == NULL) {
    pixels_ = new ::speedracer_proto::DataBuffer;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentBuffers.pixels)
  return pixels_;
}
inline void ImageFragmentBuffers::set_allocated_pixels(::speedracer_proto::DataBuffer* pixels) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pixels_;
  }
  if (pixels) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pixels = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pixels, submessage_arena);
    }
    
  } else {
    
  }
  pixels_ = pixels;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentBuffers.pixels)
}

// .speedracer_proto.DataBuffer depth = 3;
inline bool ImageFragmentBuffers::has_depth() const {
  return this != internal_default_instance() && depth_ != NULL;
}
inline void ImageFragmentBuffers::clear_depth() {
  if (GetArenaNoVirtual() == NULL && depth_ != NULL) {
    delete depth_;
  }
  depth_ = NULL;
}
inline const ::speedracer_proto::DataBuffer& ImageFragmentBuffers::depth() const {
  const ::speedracer_proto::DataBuffer* p = depth_;
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentBuffers.depth)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::DataBuffer*>(
      &::speedracer_proto::_DataBuffer_default_instance_);
}
inline ::speedracer_proto::DataBuffer* ImageFragmentBuffers::release_depth() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentBuffers.depth)
  
  ::speedracer_proto::DataBuffer* temp = depth_;
  depth_ = NULL;
  return temp;
}
inline ::speedracer_proto::DataBuffer* ImageFragmentBuffers::mutable_depth() {
  
  if (depth_ == NULL) {
    depth_ = new ::speedracer_proto::DataBuffer;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentBuffers.depth)
  return depth_;
}
inline void ImageFragmentBuffers::set_allocated_depth(::speedracer_proto::DataBuffer* depth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete depth_;
  }
  if (depth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      depth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, depth, submessage_arena);
    }
    
  } else {
    
  }
  depth_ = depth;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentBuffers.depth)
}

// -------------------------------------------------------------------

// ImageFragmentInfo

// string key = 1;
inline void ImageFragmentInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageFragmentInfo::key() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentInfo.key)
  return key_.GetNoArena();
}
inline void ImageFragmentInfo::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speedracer_proto.ImageFragmentInfo.key)
}
#if LANG_CXX11
inline void ImageFragmentInfo::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speedracer_proto.ImageFragmentInfo.key)
}
#endif
inline void ImageFragmentInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speedracer_proto.ImageFragmentInfo.key)
}
inline void ImageFragmentInfo::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speedracer_proto.ImageFragmentInfo.key)
}
inline ::std::string* ImageFragmentInfo::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageFragmentInfo::release_key() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentInfo.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageFragmentInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentInfo.key)
}

// .speedracer_proto.BoundingBox2i bounds = 2;
inline bool ImageFragmentInfo::has_bounds() const {
  return this != internal_default_instance() && bounds_ != NULL;
}
inline void ImageFragmentInfo::clear_bounds() {
  if (GetArenaNoVirtual() == NULL && bounds_ != NULL) {
    delete bounds_;
  }
  bounds_ = NULL;
}
inline const ::speedracer_proto::BoundingBox2i& ImageFragmentInfo::bounds() const {
  const ::speedracer_proto::BoundingBox2i* p = bounds_;
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentInfo.bounds)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::BoundingBox2i*>(
      &::speedracer_proto::_BoundingBox2i_default_instance_);
}
inline ::speedracer_proto::BoundingBox2i* ImageFragmentInfo::release_bounds() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentInfo.bounds)
  
  ::speedracer_proto::BoundingBox2i* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline ::speedracer_proto::BoundingBox2i* ImageFragmentInfo::mutable_bounds() {
  
  if (bounds_ == NULL) {
    bounds_ = new ::speedracer_proto::BoundingBox2i;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentInfo.bounds)
  return bounds_;
}
inline void ImageFragmentInfo::set_allocated_bounds(::speedracer_proto::BoundingBox2i* bounds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounds_;
  }
  if (bounds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentInfo.bounds)
}

// bool isOpaque = 3;
inline void ImageFragmentInfo::clear_isopaque() {
  isopaque_ = false;
}
inline bool ImageFragmentInfo::isopaque() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentInfo.isOpaque)
  return isopaque_;
}
inline void ImageFragmentInfo::set_isopaque(bool value) {
  
  isopaque_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.ImageFragmentInfo.isOpaque)
}

// -------------------------------------------------------------------

// ImageFragmentList

// .speedracer_proto.FrameID frame = 1;
inline bool ImageFragmentList::has_frame() const {
  return this != internal_default_instance() && frame_ != NULL;
}
inline void ImageFragmentList::clear_frame() {
  if (GetArenaNoVirtual() == NULL && frame_ != NULL) {
    delete frame_;
  }
  frame_ = NULL;
}
inline const ::speedracer_proto::FrameID& ImageFragmentList::frame() const {
  const ::speedracer_proto::FrameID* p = frame_;
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentList.frame)
  return p != NULL ? *p : *reinterpret_cast<const ::speedracer_proto::FrameID*>(
      &::speedracer_proto::_FrameID_default_instance_);
}
inline ::speedracer_proto::FrameID* ImageFragmentList::release_frame() {
  // @@protoc_insertion_point(field_release:speedracer_proto.ImageFragmentList.frame)
  
  ::speedracer_proto::FrameID* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline ::speedracer_proto::FrameID* ImageFragmentList::mutable_frame() {
  
  if (frame_ == NULL) {
    frame_ = new ::speedracer_proto::FrameID;
  }
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentList.frame)
  return frame_;
}
inline void ImageFragmentList::set_allocated_frame(::speedracer_proto::FrameID* frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete frame_;
  }
  if (frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:speedracer_proto.ImageFragmentList.frame)
}

// repeated .speedracer_proto.ImageFragmentInfo fragments = 2;
inline int ImageFragmentList::fragments_size() const {
  return fragments_.size();
}
inline void ImageFragmentList::clear_fragments() {
  fragments_.Clear();
}
inline const ::speedracer_proto::ImageFragmentInfo& ImageFragmentList::fragments(int index) const {
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentList.fragments)
  return fragments_.Get(index);
}
inline ::speedracer_proto::ImageFragmentInfo* ImageFragmentList::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:speedracer_proto.ImageFragmentList.fragments)
  return fragments_.Mutable(index);
}
inline ::speedracer_proto::ImageFragmentInfo* ImageFragmentList::add_fragments() {
  // @@protoc_insertion_point(field_add:speedracer_proto.ImageFragmentList.fragments)
  return fragments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::speedracer_proto::ImageFragmentInfo >*
ImageFragmentList::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:speedracer_proto.ImageFragmentList.fragments)
  return &fragments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::speedracer_proto::ImageFragmentInfo >&
ImageFragmentList::fragments() const {
  // @@protoc_insertion_point(field_list:speedracer_proto.ImageFragmentList.fragments)
  return fragments_;
}

// int32 totalCount = 3;
inline void ImageFragmentList::clear_totalcount() {
  totalcount_ = 0;
}
inline ::google::protobuf::int32 ImageFragmentList::totalcount() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentList.totalCount)
  return totalcount_;
}
inline void ImageFragmentList::set_totalcount(::google::protobuf::int32 value) {
  
  totalcount_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.ImageFragmentList.totalCount)
}

// int32 accumCount = 4;
inline void ImageFragmentList::clear_accumcount() {
  accumcount_ = 0;
}
inline ::google::protobuf::int32 ImageFragmentList::accumcount() const {
  // @@protoc_insertion_point(field_get:speedracer_proto.ImageFragmentList.accumCount)
  return accumcount_;
}
inline void ImageFragmentList::set_accumcount(::google::protobuf::int32 value) {
  
  accumcount_ = value;
  // @@protoc_insertion_point(field_set:speedracer_proto.ImageFragmentList.accumCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace speedracer_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::speedracer_proto::DataBufferFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speedracer_proto::DataBufferFormat>() {
  return ::speedracer_proto::DataBufferFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_schemata_2fRenderJob_2eproto__INCLUDED
